<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Packet Plumbing</title>
    <link rel="stylesheet" href="/index.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <section class="section">
        <div class="container">
            

<div class="title">
    <h1 class="title">
        The Programmable Data Plane and the OS
    </h1>
</div>
<div class="subtitle blogsub sectiontitle">
    <span class="date draft">2022-02-22</span>
    <span class="draft draftmarker">Draft</span>
    <a class="path" href="/">~</a> /
    <a class="path" href="/architecture">architecture</a> /
</div>
<h2 id="background">Background</h2>
<p>Over the last decade or so, data networks have become increasingly programmable.
Fixed function network interface cards and switch ASICs – once the only option – are now readily available in various programmable forms. Much of the work in this
space, sometimes referred to “software defined networking” has focused on the
development of new protocols, often skipping the operating system's networking
stack all together.</p>
<p>The programmable data plane also offers potential advantages to the OS network 
stack. First and foremost, network hardware is no longer a black box. This means
that <strong><em>interactions between kernel-level network functions and network functions
exposed by hardware can be analyzed and understood as a combined whole</em></strong>. A
programmable data plane also democratizes development of kernel-level network
features by putting a community of kernel developers in the driver seat rather
than living at the mercy of proprietary firmware.</p>
<p>A formidable challenge in incorporating a programmable data plane at the OS level
is supporting the large breadth of network protocols that are required. From
servers, to laptops to embedded devices – the number and variety of protocols 
that must work <em>together</em> for the operating system's networking stack to
function effectively presents a different set of challenges than
incorporating a programmable data plane for one-off kernel-bypass programs.</p>
<h2 id="network-functions-at-the-hardware-software-interface">Network Functions at the Hardware/Software Interface</h2>
<p>The following network functions are a few simple examples of how OS-level and
firmware-level network functions interact. In this post we'll refer to firmware
simply as code that executes on a network device independently of the
operating system. The examples presented are nowhere near an exhaustive list.
Take a look at the data sheet for any modern data-center NIC <sup class="footnote-reference"><a href="#1">1</a></sup> <sup class="footnote-reference"><a href="#2">2</a></sup> <sup class="footnote-reference"><a href="#3">3</a></sup>, and
you'll find dozens of network functions that are implemented by these devices.</p>
<h3 id="checksum-offload">Checksum Offload</h3>
<h3 id="tcp-offload">TCP Offload</h3>
<h3 id="tunnel-encap-decap-offload">Tunnel Encap/Decap Offload</h3>
<h3 id="pushing-more-functionality-onto-network-processing-units">Pushing more functionality onto network processing units</h3>
<p>Ideally, the central processing unit on a computer is dedicated to executing the
code of programs running on the computer, and spends few cycles as possible
performing network functions. This leaves the execution of network functions to
network processing units (<strong>NPU</strong>). However, for some network functions, the OS
must be aware of a subset of the state involved and how it evolves. This is
called <strong>stateful offload</strong>. Functions that can be completely offloaded to an
NPU and the OS can remain happily oblivious to what's going are referred to as <strong>stateless
offload</strong>.</p>
<h2 id="the-fragmented-state-of-data-plane-compilers-and-control-interfaces">The Fragmented state of Data Plane Compilers and Control Interfaces</h2>
<h2 id="an-os-level-programmable-data-plane-architecture">An OS-Level Programmable Data Plane Architecture</h2>
<h2 id="working-backwards-from-the-ideal-interface">Working Backwards from the Ideal Interface</h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://cdrdv2.intel.com/v1/dl/getContent/639389?explicitVersion=true">Intel 800 series</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://www.mellanox.com/files/doc-2020/pb-connectx-6-dx-en-card.pdf">Mellanox ConnectX-6</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="https://www.chelsio.com/wp-content/uploads/resources/Chelsio-Terminator-6-Brief.pdf">Chelsio T6</a></p>
</div>


        </div>
    </section>
</body>

<html>
